<!DOCTYPE html>
<html>
<head>
  <title>Web 1.0 Tiled Background Generator</title>
   <link rel="stylesheet" href="styles.css">

</head>
<body>
  <div class="container">
    <div class="title-bar">
      <span>Bienvenidos a mi portfolio</span>
      <div class="title-bar-controls">
        <div class="title-bar-button">_</div>
        <div class="title-bar-button">â–¡</div>
        <div class="title-bar-button">X</div>
      </div>
    </div>
    <div class="window">
      <div class="window-content">
        <div class="ascii-art">
__________         _____              .__      ________                     .__                  
\______   \_____ _/ ____\____    ____ |  |    /  _____/  ____   ____ _______|  |   ____ ________ 
 |       _/\__  \\   __\\__  \ _/ __ \|  |   /   \  ___ /  _ \ /    \\___   /  | _/ __ \\___   / 
 |    |   \ / __ \|  |   / __ \\  ___/|  |__ \    \_\  (  <_> )   |  \/    /|  |_\  ___/ /    /  
 |____|_  /(____  /__|  (____  /\___  >____/  \______  /\____/|___|  /_____ \____/\___  >_____ \ 
        \/      \/           \/     \/               \/            \/      \/         \/      \/ 
   _____                 __                                                                      
  /     \ _____ ________/  |_  ____                                                              
 /  \ /  \\__  \\_  __ \   __\/    \                                                             
/    Y    \/ __ \|  | \/|  | |   |  \                                                            
\____|__  (____  /__|   |__| |___|  /                                                            
        \/     \/                 \/     
    </div>

        <div class="panel">
          <div class="panel-title">Pattern Properties</div>
          
          <div style="display: flex; flex-direction: row;">
            <div style="flex: 1;">
              <div class="control-group">
                <div class="control-label">Pattern Type:</div>
                <div class="tab-container">
                  <div class="tab-row">
                    <div class="tab active" id="basicTab">Basic</div>
                    <div class="tab" id="complexTab">Complex</div>
                  </div>
                  <div class="tab-content" id="basicTabContent">
                    <div class="radio-group">
                      <label class="radio-label">
                        <input type="radio" name="patternType" value="grid" checked> Grid
                      </label>
                      <label class="radio-label">
                        <input type="radio" name="patternType" value="dots"> Dots
                      </label>
                      <label class="radio-label">
                        <input type="radio" name="patternType" value="checks"> Checks
                      </label>
                      <label class="radio-label">
                        <input type="radio" name="patternType" value="stripes"> Stripes
                      </label>
                      <label class="radio-label">
                        <input type="radio" name="patternType" value="zigzag"> Zigzag
                      </label>
                      <label class="radio-label">
                        <input type="radio" name="patternType" value="ascii"> ASCII
                      </label>
                    </div>
                  </div>
                  <div class="tab-content" id="complexTabContent" style="display: none;">
                    <div class="radio-group">
                      <label class="radio-label">
                        <input type="radio" name="patternType" value="diamonds"> Diamonds
                      </label>
                      <label class="radio-label">
                        <input type="radio" name="patternType" value="triangles"> Triangles
                      </label>
                      <label class="radio-label">
                        <input type="radio" name="patternType" value="circles"> Circles
                      </label>
                      <label class="radio-label">
                        <input type="radio" name="patternType" value="pixel"> Pixel Art
                      </label>
                      <label class="radio-label">
                        <input type="radio" name="patternType" value="retro"> Retro CPU
                      </label>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            
            <!-- Larger Live Preview in the upper right corner -->
            <div style="width: 200px; margin-left: 10px;">
              <div class="preview-window">
                <div class="preview-title-bar">Live Preview</div>
                <div class="preview-content">
                  <canvas id="preview" width="180" height="180"></canvas>
                </div>
              </div>
            </div>
          </div>

          <div class="control-group">
            <div class="control-label">Primary Color:</div>
            <div style="display: flex; align-items: center;">
              <input type="color" id="primaryColor" class="color-input" value="#000000">
              <input type="text" id="primaryColorText" value="#000000" style="width: 70px;">
            </div>
          </div>

          <div class="control-group">
            <div class="control-label">Background Color:</div>
            <div style="display: flex; align-items: center;">
              <input type="color" id="bgColor" class="color-input" value="#FFFFFF">
              <input type="text" id="bgColorText" value="#FFFFFF" style="width: 70px;">
            </div>
          </div>

          <div class="control-group">
            <div class="control-label">Secondary Color:</div>
            <div style="display: flex; align-items: center;">
              <input type="color" id="secondaryColor" class="color-input" value="#C0C0C0">
              <input type="text" id="secondaryColorText" value="#C0C0C0" style="width: 70px;">
            </div>
          </div>

          <div class="control-group">
            <div class="control-label">Size (px): <span id="sizeValue">20</span></div>
            <div class="slider-container">
              <input type="range" id="sizeSlider" min="5" max="100" value="20">
            </div>
          </div>

          <div class="control-group">
            <div class="control-label">Spacing (px): <span id="spacingValue">2</span></div>
            <div class="slider-container">
              <input type="range" id="spacingSlider" min="0" max="50" value="2">
            </div>
          </div>

          <div class="control-group">
            <div class="control-label">Rotation (deg): <span id="rotationValue">0</span></div>
            <div class="slider-container">
              <input type="range" id="rotationSlider" min="0" max="360" value="0">
            </div>
          </div>

          <div class="control-group">
            <label class="checkbox-label">
              <input type="checkbox" id="animatedCheckbox">
              Animated
            </label>
          </div>

          <div class="control-group" id="animationSpeedContainer" style="display: none;">
            <div class="control-label">Animation Speed: <span id="animationSpeedValue">5</span></div>
            <div class="slider-container">
              <input type="range" id="animationSpeedSlider" min="1" max="10" value="5">
            </div>
          </div>
          
          <div class="control-group">
            <div class="control-label">Tile Size (px):</div>
            <div style="display: flex; align-items: center;">
              <span style="margin-right: 5px;">Width:</span>
              <input type="number" id="tileWidth" min="50" max="500" value="100" style="width: 60px;">
              <span style="margin: 0 5px;">Height:</span>
              <input type="number" id="tileHeight" min="50" max="500" value="100" style="width: 60px;">
            </div>
          </div>
        </div>

        <div class="panel">
          <div class="panel-title">Customization</div>
          <div class="control-group">
            <div class="control-label">Upload Image:</div>
            <input type="file" id="imageUpload" accept="image/*" class="file-input">
            <div class="upload-preview" id="uploadPreview">
              <div class="upload-placeholder">No image</div>
            </div>
          </div>
          <div class="control-group">
            <div class="control-label">Image Options:</div>
            <div style="display: flex; flex-direction: column; gap: 5px;">
              <label class="radio-label">
                <input type="radio" name="imageMode" value="overlay" checked> Overlay on Pattern
              </label>
              <label class="radio-label">
                <input type="radio" name="imageMode" value="background"> Use as Background
              </label>
              <label class="radio-label">
                <input type="radio" name="imageMode" value="tile"> Tile Image
              </label>
            </div>
          </div>
          <div class="control-group">
            <div class="control-label">Image Opacity: <span id="imageOpacityValue">100</span>%</div>
            <div class="slider-container">
              <input type="range" id="imageOpacitySlider" min="10" max="100" value="100">
            </div>
          </div>
          <div class="control-group">
            <div class="control-label">Add Text:</div>
            <input type="text" id="textInput" placeholder="Enter text..." style="width: 100%; margin-bottom: 5px; border: 2px inset #808080; padding: 2px;">
            <div style="display: flex; align-items: center; margin-bottom: 5px;">
              <div class="button" id="addTextBtn" style="margin-right: 5px; min-width: 60px;">Add</div>
              <select id="fontSelect" style="flex-grow: 1;">
                <option value="Arial">Arial</option>
                <option value="Courier New">Courier New</option>
                <option value="Times New Roman">Times New Roman</option>
                <option value="Verdana">Verdana</option>
                <option value="Impact">Impact</option>
              </select>
            </div>
            <div style="display: flex; align-items: center;">
              <input type="color" id="textColor" class="color-input" value="#000000">
              <select id="textSize" style="margin-left: 5px;">
                <option value="12">12px</option>
                <option value="16">16px</option>
                <option value="20">20px</option>
                <option value="24">24px</option>
                <option value="32">32px</option>
              </select>
              <div class="button" id="clearCustomBtn" style="margin-left: 5px; min-width: 60px;">Clear</div>
            </div>
          </div>
          <div class="control-group">
            <div class="control-label">Drawing:</div>
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
              <input type="color" id="drawColor" class="color-input" value="#FF0000">
              <select id="brushSize" style="margin-left: 5px;">
                <option value="1">1px</option>
                <option value="3" selected>3px</option>
                <option value="5">5px</option>
                <option value="8">8px</option>
                <option value="12">12px</option>
              </select>
              <div class="button" id="drawModeBtn" style="margin-left: 5px; min-width: 80px;">Start Drawing</div>
            </div>
          </div>
        </div>

        <div class="panel">
          <div class="panel-title">Controls</div>
          <div class="button-row">
            <div class="button" id="generateBtn">Generate</div>
            <div class="button" id="randomizeBtn">Randomize</div>
            <div class="button" id="exportBtn">Export</div>
          </div>
        </div>

        <div class="panel">
          <div class="panel-title">Export Options</div>
          <div class="control-group">
            <div class="control-label">Format:</div>
            <select id="exportFormat">
              <option value="png">PNG</option>
              <option value="jpg">JPG</option>
              <option value="gif">GIF</option>
            </select>
          </div>
          <div class="control-group">
            <div class="control-label">Export Size:</div>
            <div style="display: flex; align-items: center;">
              <span style="margin-right: 5px;">Width:</span>
              <input type="number" id="exportWidth" min="100" max="2000" value="500" style="width: 60px;">
              <span style="margin: 0 5px;">Height:</span>
              <input type="number" id="exportHeight" min="100" max="2000" value="500" style="width: 60px;">
            </div>
          </div>
          <label class="checkbox-label">
            <input type="checkbox" id="tileBgCheckbox" checked>
            Tile background (for CSS)
          </label>
          <label class="checkbox-label">
            <input type="checkbox" id="includeCustomCheckbox" checked>
            Include custom elements (image/text/drawing)
          </label>
        </div>

        <div class="status-bar">
          Ready | Tile size: <span id="statusTileSize">100x100</span> | <span id="statusMessage">No file exported</span>
        </div>
      </div>
    </div>
    <a id="downloadLink"></a>
  </div>

  <script>
    // DOM Elements
    const preview = document.getElementById('preview');
    const ctx = preview.getContext('2d');
    const generateBtn = document.getElementById('generateBtn');
    const randomizeBtn = document.getElementById('randomizeBtn');
    const exportBtn = document.getElementById('exportBtn');
    const downloadLink = document.getElementById('downloadLink');
    
    // Input Elements
    const patternTypeRadios = document.querySelectorAll('input[name="patternType"]');
    const primaryColorInput = document.getElementById('primaryColor');
    const primaryColorText = document.getElementById('primaryColorText');
    const bgColorInput = document.getElementById('bgColor');
    const bgColorText = document.getElementById('bgColorText');
    const secondaryColorInput = document.getElementById('secondaryColor');
    const secondaryColorText = document.getElementById('secondaryColorText');
    const sizeSlider = document.getElementById('sizeSlider');
    const sizeValue = document.getElementById('sizeValue');
    const spacingSlider = document.getElementById('spacingSlider');
    const spacingValue = document.getElementById('spacingValue');
    const rotationSlider = document.getElementById('rotationSlider');
    const rotationValue = document.getElementById('rotationValue');
    const animatedCheckbox = document.getElementById('animatedCheckbox');
    const animationSpeedContainer = document.getElementById('animationSpeedContainer');
    const animationSpeedSlider = document.getElementById('animationSpeedSlider');
    const animationSpeedValue = document.getElementById('animationSpeedValue');
    const tileWidthInput = document.getElementById('tileWidth');
    const tileHeightInput = document.getElementById('tileHeight');
    const exportFormatSelect = document.getElementById('exportFormat');
    const exportWidthInput = document.getElementById('exportWidth');
    const exportHeightInput = document.getElementById('exportHeight');
    const tileBgCheckbox = document.getElementById('tileBgCheckbox');
    const includeCustomCheckbox = document.getElementById('includeCustomCheckbox');
    const statusTileSize = document.getElementById('statusTileSize');
    const statusMessage = document.getElementById('statusMessage');

    // Custom elements tracking
    let customImage = null;
    let imageMode = 'overlay';
    let imageOpacity = 1;
    let customElements = [];
    let isDrawing = false;
    let drawingMode = false;

    // Pattern state
    let patternState = {
      type: 'grid',
      primaryColor: '#000000',
      bgColor: '#FFFFFF',
      secondaryColor: '#C0C0C0',
      size: 20,
      spacing: 2,
      rotation: 0,
      animated: false,
      animationSpeed: 5,
      tileWidth: 100,
      tileHeight: 100
    };

    // Animation variables
    let animationId = null;
    let animationPhase = 0;

    // Initialize
    function init() {
      // Set up canvas size
      resizeCanvas();
      
      // Event listeners for controls
      setupEventListeners();
      
      // Generate initial pattern
      generatePattern();
    }

    function resizeCanvas() {
      // Preview is fixed at 180x180
      preview.width = 180;
      preview.height = 180;
      
      // Update status
      statusTileSize.textContent = `${patternState.tileWidth}x${patternState.tileHeight}`;
    }

    function setupEventListeners() {
      // Tabs
      const basicTab = document.getElementById('basicTab');
      const complexTab = document.getElementById('complexTab');
      const basicTabContent = document.getElementById('basicTabContent');
      const complexTabContent = document.getElementById('complexTabContent');
      
      basicTab.addEventListener('click', function() {
        basicTab.classList.add('active');
        complexTab.classList.remove('active');
        basicTabContent.style.display = 'block';
        complexTabContent.style.display = 'none';
      });
      
      complexTab.addEventListener('click', function() {
        complexTab.classList.add('active');
        basicTab.classList.remove('active');
        complexTabContent.style.display = 'block';
        basicTabContent.style.display = 'none';
      });
      
      // Pattern type
      patternTypeRadios.forEach(radio => {
        radio.addEventListener('change', function() {
          if (radio.checked) {
            patternState.type = radio.value;
            generatePattern();
          }
        });
      });

      // Color inputs
      primaryColorInput.addEventListener('input', function() {
        patternState.primaryColor = primaryColorInput.value;
        primaryColorText.value = primaryColorInput.value;
        generatePattern();
      });

      primaryColorText.addEventListener('input', function() {
        if (/^#[0-9A-F]{6}$/i.test(primaryColorText.value)) {
          patternState.primaryColor = primaryColorText.value;
          primaryColorInput.value = primaryColorText.value;
          generatePattern();
        }
      });

      bgColorInput.addEventListener('input', function() {
        patternState.bgColor = bgColorInput.value;
        bgColorText.value = bgColorInput.value;
        generatePattern();
      });

      bgColorText.addEventListener('input', function() {
        if (/^#[0-9A-F]{6}$/i.test(bgColorText.value)) {
          patternState.bgColor = bgColorText.value;
          bgColorInput.value = bgColorText.value;
          generatePattern();
        }
      });

      secondaryColorInput.addEventListener('input', function() {
        patternState.secondaryColor = secondaryColorInput.value;
        secondaryColorText.value = secondaryColorInput.value;
        generatePattern();
      });

      secondaryColorText.addEventListener('input', function() {
        if (/^#[0-9A-F]{6}$/i.test(secondaryColorText.value)) {
          patternState.secondaryColor = secondaryColorText.value;
          secondaryColorInput.value = secondaryColorText.value;
          generatePattern();
        }
      });

      // Size slider
      sizeSlider.addEventListener('input', function() {
        patternState.size = parseInt(sizeSlider.value);
        sizeValue.textContent = patternState.size;
        generatePattern();
      });

      // Spacing slider
      spacingSlider.addEventListener('input', function() {
        patternState.spacing = parseInt(spacingSlider.value);
        spacingValue.textContent = patternState.spacing;
        generatePattern();
      });

      // Rotation slider
      rotationSlider.addEventListener('input', function() {
        patternState.rotation = parseInt(rotationSlider.value);
        rotationValue.textContent = patternState.rotation;
        generatePattern();
      });

      // Animation checkbox
      animatedCheckbox.addEventListener('change', function() {
        patternState.animated = animatedCheckbox.checked;
        animationSpeedContainer.style.display = patternState.animated ? 'block' : 'none';
        
        if (patternState.animated) {
          startAnimation();
        } else {
          stopAnimation();
          generatePattern();
        }
      });

      // Animation speed slider
      animationSpeedSlider.addEventListener('input', function() {
        patternState.animationSpeed = parseInt(animationSpeedSlider.value);
        animationSpeedValue.textContent = patternState.animationSpeed;
      });

      // Tile size inputs
      tileWidthInput.addEventListener('change', function() {
        patternState.tileWidth = parseInt(tileWidthInput.value);
        resizeCanvas();
        generatePattern();
      });

      tileHeightInput.addEventListener('change', function() {
        patternState.tileHeight = parseInt(tileHeightInput.value);
        resizeCanvas();
        generatePattern();
      });

      // Custom image upload
      const imageUpload = document.getElementById('imageUpload');
      const uploadPreview = document.getElementById('uploadPreview');
      
      imageUpload.addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          
          reader.onload = function(event) {
            // Create an image element
            const img = new Image();
            
            img.onload = function() {
              // Store the image
              customImage = img;
              
              // Update the preview
              uploadPreview.innerHTML = '';
              const previewImg = document.createElement('img');
              previewImg.src = event.target.result;
              previewImg.style.maxWidth = '100%';
              previewImg.style.maxHeight = '100%';
              uploadPreview.appendChild(previewImg);
              
              // Regenerate the pattern with the image
              generatePattern();
            };
            
            img.src = event.target.result;
          };
          
          reader.readAsDataURL(file);
        }
      });
      
      // Image mode selection
      const imageModeRadios = document.querySelectorAll('input[name="imageMode"]');
      
      imageModeRadios.forEach(radio => {
        radio.addEventListener('change', function() {
          if (radio.checked) {
            imageMode = radio.value;
            generatePattern();
          }
        });
      });
      
      // Image opacity slider
      const imageOpacitySlider = document.getElementById('imageOpacitySlider');
      const imageOpacityValue = document.getElementById('imageOpacityValue');
      
      imageOpacitySlider.addEventListener('input', function() {
        imageOpacity = parseInt(imageOpacitySlider.value) / 100;
        imageOpacityValue.textContent = imageOpacitySlider.value;
        generatePattern();
      });
      
      // Text adding
      const textInput = document.getElementById('textInput');
      const addTextBtn = document.getElementById('addTextBtn');
      const fontSelect = document.getElementById('fontSelect');
      const textColor = document.getElementById('textColor');
      const textSize = document.getElementById('textSize');
      
      addTextBtn.addEventListener('click', function() {
        const text = textInput.value.trim();
        if (text) {
          // Add text to canvas at center
          const fontSize = parseInt(textSize.value);
          ctx.font = `${fontSize}px ${fontSelect.value}`;
          
          // Calculate centered position
          const textWidth = ctx.measureText(text).width;
          const x = (preview.width - textWidth) / 2;
          const y = preview.height / 2;
          
          // Add to custom elements
          customElements.push({
            type: 'text',
            text: text,
            x: x,
            y: y,
            font: fontSelect.value,
            size: fontSize,
            color: textColor.value
          });
          
          // Clear input
          textInput.value = '';
          
          // Redraw
          generatePattern();
        }
      });
      
      // Drawing mode
      const drawModeBtn = document.getElementById('drawModeBtn');
      const drawColor = document.getElementById('drawColor');
      const brushSize = document.getElementById('brushSize');
      
      drawModeBtn.addEventListener('click', function() {
        drawingMode = !drawingMode;
        
        if (drawingMode) {
          drawModeBtn.textContent = 'Stop Drawing';
          drawModeBtn.style.backgroundColor = '#FF9999';
          
          // Set up drawing event listeners
          preview.addEventListener('mousedown', startDrawing);
          preview.addEventListener('mousemove', draw);
          preview.addEventListener('mouseup', stopDrawing);
          preview.addEventListener('mouseleave', stopDrawing);
          
          // Change cursor
          preview.style.cursor = 'crosshair';
        } else {
          drawModeBtn.textContent = 'Start Drawing';
          drawModeBtn.style.backgroundColor = '';
          
          // Remove drawing event listeners
          preview.removeEventListener('mousedown', startDrawing);
          preview.removeEventListener('mousemove', draw);
          preview.removeEventListener('mouseup', stopDrawing);
          preview.removeEventListener('mouseleave', stopDrawing);
          
          // Reset cursor
          preview.style.cursor = 'default';
        }
      });
      
      // Clear custom elements
      const clearCustomBtn = document.getElementById('clearCustomBtn');
      
      clearCustomBtn.addEventListener('click', function() {
        customElements = [];
        generatePattern();
      });

      // Buttons
      generateBtn.addEventListener('click', generatePattern);
      randomizeBtn.addEventListener('click', randomizePattern);
      exportBtn.addEventListener('click', exportPattern);
    }

    // Drawing functions
    function startDrawing(e) {
      isDrawing = true;
      
      // Get mouse position relative to canvas
      const rect = preview.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      // Create a new drawing element
      const currentDrawing = {
        type: 'drawing',
        color: document.getElementById('drawColor').value,
        brushSize: parseInt(document.getElementById('brushSize').value),
        points: [{x, y}]
      };
      
      // Add to custom elements
      customElements.push(currentDrawing);
      
      // Draw the first point
      generatePattern();
    }
    
    function draw(e) {
      if (!isDrawing) return;
      
      // Get mouse position
      const rect = preview.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      // Add point to current drawing
      const currentDrawing = customElements[customElements.length - 1];
      currentDrawing.points.push({x, y});
      
      // Redraw
      generatePattern();
    }
    
    function stopDrawing() {
      isDrawing = false;
    }

    function startAnimation() {
      if (animationId) {
        cancelAnimationFrame(animationId);
      }
      
      function animate() {
        animationPhase += 0.02 * patternState.animationSpeed;
        generatePattern(true);
        animationId = requestAnimationFrame(animate);
      }
      
      animationId = requestAnimationFrame(animate);
    }

    function stopAnimation() {
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
    }

    function generatePattern(isAnimating = false) {
      // Clear canvas
      ctx.clearRect(0, 0, preview.width, preview.height);
      
      // If using image as background
      if (customImage !== null && imageMode === 'background') {
        ctx.globalAlpha = imageOpacity;
        drawImageProperly(customImage);
        ctx.globalAlpha = 1;
      } else {
        // Fill with background color
        ctx.fillStyle = patternState.bgColor;
        ctx.fillRect(0, 0, preview.width, preview.height);
      }
      
      // Draw pattern based on type
      switch (patternState.type) {
        case 'grid':
          drawGrid(isAnimating);
          break;
        case 'dots':
          drawDots(isAnimating);
          break;
        case 'checks':
          drawChecks(isAnimating);
          break;
        case 'stripes':
          drawStripes(isAnimating);
          break;
        case 'zigzag':
          drawZigzag(isAnimating);
          break;
        case 'ascii':
          drawAscii(isAnimating);
          break;
        case 'diamonds':
          drawDiamonds(isAnimating);
          break;
        case 'triangles':
          drawTriangles(isAnimating);
          break;
        case 'circles':
          drawCircles(isAnimating);
          break;
        case 'pixel':
          drawPixelArt(isAnimating);
          break;
        case 'retro':
          drawRetroCPU(isAnimating);
          break;
      }
      
      // Draw tiled image if selected
      if (customImage !== null && imageMode === 'tile') {
        const tileSize = Math.min(customImage.width, customImage.height, preview.width / 4, preview.height / 4);
        const pattern = ctx.createPattern(customImage, 'repeat');
        ctx.globalAlpha = imageOpacity;
        ctx.fillStyle = pattern;
        ctx.fillRect(0, 0, preview.width, preview.height);
        ctx.globalAlpha = 1;
      }
      
      // Draw image overlay if selected
      if (customImage !== null && imageMode === 'overlay') {
        ctx.globalAlpha = imageOpacity;
        drawImageProperly(customImage);
        ctx.globalAlpha = 1;
      }
      
      // Draw custom elements (text and drawings)
      drawCustomElements();
    }
    
    function drawImageProperly(image) {
      // Calculate proportions to fit the image properly
      const imgRatio = image.width / image.height;
      const canvasRatio = preview.width / preview.height;
      let drawWidth, drawHeight, drawX, drawY;
      
      if (imgRatio > canvasRatio) {
        // Image is wider than canvas proportionally
        drawWidth = preview.width;
        drawHeight = preview.width / imgRatio;
        drawX = 0;
        drawY = (preview.height - drawHeight) / 2;
      } else {
        // Image is taller than canvas proportionally
        drawHeight = preview.height;
        drawWidth = preview.height * imgRatio;
        drawX = (preview.width - drawWidth) / 2;
        drawY = 0;
      }
      
      // Draw the image
      ctx.drawImage(image, drawX, drawY, drawWidth, drawHeight);
    }
    
    function drawCustomElements() {
      // Draw all stored custom elements (text and drawings)
      for (let element of customElements) {
        if (element.type === 'text') {
          // Draw text element
          ctx.font = `${element.size}px ${element.font}`;
          ctx.fillStyle = element.color;
          ctx.textBaseline = 'top';
          ctx.fillText(element.text, element.x, element.y);
        } else if (element.type === 'drawing') {
          // Draw path element
          ctx.strokeStyle = element.color;
          ctx.lineWidth = element.brushSize;
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
          
          ctx.beginPath();
          for (let i = 0; i < element.points.length; i++) {
            const point = element.points[i];
            if (i === 0) {
              ctx.moveTo(point.x, point.y);
            } else {
              ctx.lineTo(point.x, point.y);
            }
          }
          ctx.stroke();
        }
      }
    }

    function drawGrid(isAnimating, context = ctx) {
      const { size, spacing, rotation, primaryColor } = patternState;
      const adjustedSize = isAnimating ? size + Math.sin(animationPhase) * 5 : size;
      
      // Save context
      context.save();
      
      // Rotate from center
      context.translate(preview.width / 2, preview.height / 2);
      context.rotate(rotation * Math.PI / 180);
      context.translate(-preview.width / 2, -preview.height / 2);
      
      // Draw horizontal lines
      context.strokeStyle = primaryColor;
      context.lineWidth = 1;
      
      for (let y = -preview.height; y < preview.height * 2; y += adjustedSize + spacing) {
        context.beginPath();
        context.moveTo(-preview.width, y);
        context.lineTo(preview.width * 2, y);
        context.stroke();
      }
      
      // Draw vertical lines
      for (let x = -preview.width; x < preview.width * 2; x += adjustedSize + spacing) {
        context.beginPath();
        context.moveTo(x, -preview.height);
        context.lineTo(x, preview.height * 2);
        context.stroke();
      }
      
      // Restore context
      context.restore();
    }

    function drawDots(isAnimating, context = ctx) {
      const { size, spacing, rotation, primaryColor } = patternState;
      const adjustedSize = isAnimating ? size + Math.sin(animationPhase) * 3 : size;
      const radius = adjustedSize / 2;
      
      // Save context
      context.save();
      
      // Rotate from center
      context.translate(preview.width / 2, preview.height / 2);
      context.rotate(rotation * Math.PI / 180);
      context.translate(-preview.width / 2, -preview.height / 2);
      
      // Draw dots
      context.fillStyle = primaryColor;
      
      for (let y = -radius; y < preview.height + radius; y += adjustedSize + spacing) {
        for (let x = -radius; x < preview.width + radius; x += adjustedSize + spacing) {
          context.beginPath();
          context.arc(x, y, radius, 0, Math.PI * 2);
          context.fill();
        }
      }
      
      // Restore context
      context.restore();
    }

    function drawChecks(isAnimating, context = ctx) {
      const { size, spacing, rotation, primaryColor, secondaryColor } = patternState;
      const adjustedSize = isAnimating ? size + Math.sin(animationPhase) * 3 : size;
      
      // Save context
      context.save();
      
      // Rotate from center
      context.translate(preview.width / 2, preview.height / 2);
      context.rotate(rotation * Math.PI / 180);
      context.translate(-preview.width / 2, -preview.height / 2);
      
      // Draw checkerboard
      for (let y = -adjustedSize; y < preview.height + adjustedSize; y += adjustedSize + spacing) {
        for (let x = -adjustedSize; x < preview.width + adjustedSize; x += (adjustedSize + spacing) * 2) {
          // First row of checks
          context.fillStyle = primaryColor;
          context.fillRect(x, y, adjustedSize, adjustedSize);
          
          // Second row of checks (offset)
          context.fillStyle = secondaryColor;
          context.fillRect(x + adjustedSize + spacing, y, adjustedSize, adjustedSize);
        }
        
        // Offset each row
        y += adjustedSize + spacing;
        if (y >= preview.height) break;
        
        for (let x = -adjustedSize; x < preview.width + adjustedSize; x += (adjustedSize + spacing) * 2) {
          context.fillStyle = secondaryColor;
          context.fillRect(x, y, adjustedSize, adjustedSize);
          
          context.fillStyle = primaryColor;
          context.fillRect(x + adjustedSize + spacing, y, adjustedSize, adjustedSize);
        }
      }
      
      // Restore context
      context.restore();
    }

    function drawStripes(isAnimating, context = ctx) {
      const { size, spacing, rotation, primaryColor } = patternState;
      const adjustedSize = isAnimating ? size + Math.sin(animationPhase) * 3 : size;
      
      // Save context
      context.save();
      
      // Rotate from center
      context.translate(preview.width / 2, preview.height / 2);
      context.rotate(rotation * Math.PI / 180);
      context.translate(-preview.width / 2, -preview.height / 2);
      
      // Draw stripes
      context.fillStyle = primaryColor;
      
      for (let y = -preview.height; y < preview.height * 2; y += (adjustedSize + spacing) * 2) {
        context.fillRect(-preview.width, y, preview.width * 3, adjustedSize);
      }
      
      // Restore context
      context.restore();
    }

    function drawZigzag(isAnimating, context = ctx) {
      const { size, spacing, rotation, primaryColor } = patternState;
      const adjustedSize = isAnimating ? size + Math.sin(animationPhase) * 3 : size;
      
      // Save context
      context.save();
      
      // Rotate from center
      context.translate(preview.width / 2, preview.height / 2);
      context.rotate(rotation * Math.PI / 180);
      context.translate(-preview.width / 2, -preview.height / 2);
      
      // Draw zigzag
      context.strokeStyle = primaryColor;
      context.lineWidth = 2;
      
      for (let y = -preview.height; y < preview.height * 2; y += adjustedSize * 2 + spacing) {
        context.beginPath();
        
        let startX = -preview.width;
        while (startX < preview.width * 2) {
          context.moveTo(startX, y);
          context.lineTo(startX + adjustedSize, y + adjustedSize);
          context.lineTo(startX + adjustedSize * 2, y);
          
          startX += adjustedSize * 2;
        }
        
        context.stroke();
      }
      
      // Restore context
      context.restore();
    }

    function drawAscii(isAnimating, context = ctx) {
      const { size, spacing, rotation, primaryColor } = patternState;
      const adjustedSize = isAnimating ? size + Math.sin(animationPhase) * 2 : size;
      
      // Save context
      context.save();
      
      // Rotate from center
      context.translate(preview.width / 2, preview.height / 2);
      context.rotate(rotation * Math.PI / 180);
      context.translate(-preview.width / 2, -preview.height / 2);
      
      // ASCII characters to use
      const asciiChars = ['.', '*', '#', '@', ':', '+', '=', '-', '/', '\\', '|', '_'];
      
      // Set text properties
      context.font = `${adjustedSize}px monospace`;
      context.fillStyle = primaryColor;
      context.textBaseline = 'top';
      
      // Draw ASCII characters
      for (let y = -adjustedSize; y < preview.height + adjustedSize; y += adjustedSize + spacing) {
        for (let x = -adjustedSize; x < preview.width + adjustedSize; x += adjustedSize + spacing) {
          // Choose a character (randomized or based on position)
          const charIndex = isAnimating 
            ? Math.floor((x + y + animationPhase * 100) / 20) % asciiChars.length
            : Math.floor((x + y) / 20) % asciiChars.length;
          
          const char = asciiChars[charIndex];
          context.fillText(char, x, y);
        }
      }
      
      // Restore context
      context.restore();
    }

    // Advanced pattern drawing functions
    function drawDiamonds(isAnimating, context = ctx) {
      const { size, spacing, rotation, primaryColor } = patternState;
      const adjustedSize = isAnimating ? size + Math.sin(animationPhase) * 3 : size;
      
      // Save context
      context.save();
      
      // Rotate from center
      context.translate(preview.width / 2, preview.height / 2);
      context.rotate(rotation * Math.PI / 180);
      context.translate(-preview.width / 2, -preview.height / 2);
      
      // Draw diamonds
      context.fillStyle = primaryColor;
      
      for (let y = -adjustedSize; y < preview.height + adjustedSize; y += adjustedSize + spacing) {
        for (let x = -adjustedSize; x < preview.width + adjustedSize; x += adjustedSize + spacing) {
          context.beginPath();
          context.moveTo(x, y - adjustedSize/2);
          context.lineTo(x + adjustedSize/2, y);
          context.lineTo(x, y + adjustedSize/2);
          context.lineTo(x - adjustedSize/2, y);
          context.closePath();
          context.fill();
        }
      }
      
      // Restore context
      context.restore();
    }
    
    function drawTriangles(isAnimating, context = ctx) {
      const { size, spacing, rotation, primaryColor, secondaryColor } = patternState;
      const adjustedSize = isAnimating ? size + Math.sin(animationPhase) * 3 : size;
      
      // Save context
      context.save();
      
      // Rotate from center
      context.translate(preview.width / 2, preview.height / 2);
      context.rotate(rotation * Math.PI / 180);
      context.translate(-preview.width / 2, -preview.height / 2);
      
      // Draw triangles
      let row = 0;
      for (let y = -adjustedSize; y < preview.height + adjustedSize; y += (adjustedSize + spacing) * 0.75) {
        for (let x = -adjustedSize; x < preview.width + adjustedSize; x += adjustedSize + spacing) {
          context.fillStyle = row % 2 === 0 ? primaryColor : secondaryColor;
          
          context.beginPath();
          context.moveTo(x, y);
          context.lineTo(x + adjustedSize, y);
          context.lineTo(x + adjustedSize/2, y + adjustedSize);
          context.closePath();
          context.fill();
        }
        row++;
      }
      
      // Restore context
      context.restore();
    }
    
    function drawCircles(isAnimating, context = ctx) {
      const { size, spacing, rotation, primaryColor, secondaryColor } = patternState;
      const adjustedSize = isAnimating ? size + Math.sin(animationPhase) * 3 : size;
      const radius = adjustedSize / 2;
      
      // Save context
      context.save();
      
      // Rotate from center
      context.translate(preview.width / 2, preview.height / 2);
      context.rotate(rotation * Math.PI / 180);
      context.translate(-preview.width / 2, -preview.height / 2);
      
      // Draw concentric circles
      for (let y = -radius; y < preview.height + radius; y += adjustedSize + spacing) {
        for (let x = -radius; x < preview.width + radius; x += adjustedSize + spacing) {
          // Outer circle
          context.fillStyle = primaryColor;
          context.beginPath();
          context.arc(x, y, radius, 0, Math.PI * 2);
          context.fill();
          
          // Inner circle
          context.fillStyle = secondaryColor;
          context.beginPath();
          context.arc(x, y, radius / 2, 0, Math.PI * 2);
          context.fill();
        }
      }
      
      // Restore context
      context.restore();
    }
    
    function drawPixelArt(isAnimating, context = ctx) {
      const { size, spacing, rotation, primaryColor, secondaryColor } = patternState;
      const pixelSize = Math.max(2, Math.floor(size / 5));
      const adjustedSize = isAnimating ? size + Math.sin(animationPhase) * 3 : size;
      
      // Save context
      context.save();
      
      // Rotate from center
      context.translate(preview.width / 2, preview.height / 2);
      context.rotate(rotation * Math.PI / 180);
      context.translate(-preview.width / 2, -preview.height / 2);
      
      // Simple pixel art patterns
      const patterns = [
        // Smiley face
        [
          [0,0,1,1,1,1,0,0],
          [0,1,0,0,0,0,1,0],
          [1,0,1,0,0,1,0,1],
          [1,0,0,0,0,0,0,1],
          [1,0,1,0,0,1,0,1],
          [1,0,0,1,1,0,0,1],
          [0,1,0,0,0,0,1,0],
          [0,0,1,1,1,1,0,0]
        ],
        // Heart
        [
          [0,1,1,0,0,1,1,0],
          [1,1,1,1,1,1,1,1],
          [1,1,1,1,1,1,1,1],
          [1,1,1,1,1,1,1,1],
          [0,1,1,1,1,1,1,0],
          [0,0,1,1,1,1,0,0],
          [0,0,0,1,1,0,0,0],
          [0,0,0,0,0,0,0,0]
        ],
        // Star
        [
          [0,0,0,1,1,0,0,0],
          [0,0,1,1,1,1,0,0],
          [0,1,1,1,1,1,1,0],
          [1,1,1,1,1,1,1,1],
          [0,0,1,1,1,1,0,0],
          [0,1,1,0,0,1,1,0],
          [1,1,0,0,0,0,1,1],
          [0,0,0,0,0,0,0,0]
        ]
      ];
      
      // Choose pattern based on animation phase or position
      const patternIndex = isAnimating 
        ? Math.floor(animationPhase) % patterns.length
        : 0;
      
      const pattern = patterns[patternIndex];
      const patternSize = pattern.length * pixelSize;
      
      // Draw the pixel art pattern repeatedly
      for (let y = -patternSize; y < preview.height + patternSize; y += patternSize + spacing) {
        for (let x = -patternSize; x < preview.width + patternSize; x += patternSize + spacing) {
          // Draw each pixel in the pattern
          for (let py = 0; py < pattern.length; py++) {
            for (let px = 0; px < pattern[py].length; px++) {
              if (pattern[py][px] === 1) {
                context.fillStyle = primaryColor;
                context.fillRect(
                  x + px * pixelSize, 
                  y + py * pixelSize, 
                  pixelSize, 
                  pixelSize
                );
              }
            }
          }
        }
      }
      
      // Restore context
      context.restore();
    }
    
    function drawRetroCPU(isAnimating, context = ctx) {
      const { size, spacing, rotation, primaryColor, secondaryColor } = patternState;
      const adjustedSize = isAnimating ? size + Math.sin(animationPhase) * 3 : size;
      
      // Save context
      context.save();
      
      // Rotate from center
      context.translate(preview.width / 2, preview.height / 2);
      context.rotate(rotation * Math.PI / 180);
      context.translate(-preview.width / 2, -preview.height / 2);
      
      // Draw circuit board pattern
      context.strokeStyle = primaryColor;
      context.lineWidth = 2;
      
      // Horizontal and vertical lines
      for (let y = -adjustedSize; y < preview.height + adjustedSize; y += adjustedSize + spacing) {
        context.beginPath();
        context.moveTo(0, y);
        context.lineTo(preview.width, y);
        context.stroke();
        
        // Add circuit nodes
        for (let x = adjustedSize; x < preview.width; x += adjustedSize) {
          if (Math.random() > 0.7) {
            context.fillStyle = secondaryColor;
            context.beginPath();
            context.arc(x, y, 3, 0, Math.PI * 2);
            context.fill();
          }
        }
      }
      
      for (let x = -adjustedSize; x < preview.width + adjustedSize; x += adjustedSize + spacing) {
        context.beginPath();
        context.moveTo(x, 0);
        context.lineTo(x, preview.height);
        context.stroke();
        
        // Add more circuit nodes
        for (let y = adjustedSize; y < preview.height; y += adjustedSize) {
          if (Math.random() > 0.7) {
            context.fillStyle = secondaryColor;
            context.beginPath();
            context.arc(x, y, 3, 0, Math.PI * 2);
            context.fill();
            
            // Sometimes add a chip
            if (Math.random() > 0.8) {
              context.fillStyle = primaryColor;
              context.fillRect(x - 8, y - 5, 16, 10);
              
              // Chip pins
              context.fillStyle = secondaryColor;
              for (let i = -6; i <= 6; i += 4) {
                context.fillRect(x + i, y - 7, 2, 2);
                context.fillRect(x + i, y + 5, 2, 2);
              }
            }
          }
        }
      }
      
      // Restore context
      context.restore();
    }

    function randomizePattern() {
      // Randomize colors
      primaryColorInput.value = getRandomColor();
      patternState.primaryColor = primaryColorInput.value;
      primaryColorText.value = primaryColorInput.value;
      
      bgColorInput.value = getRandomColor();
      patternState.bgColor = bgColorInput.value;
      bgColorText.value = bgColorInput.value;
      
      secondaryColorInput.value = getRandomColor();
      patternState.secondaryColor = secondaryColorInput.value;
      secondaryColorText.value = secondaryColorInput.value;
      
      // Randomize size and spacing
      sizeSlider.value = Math.floor(Math.random() * 50) + 10;
      patternState.size = parseInt(sizeSlider.value);
      sizeValue.textContent = patternState.size;
      
      spacingSlider.value = Math.floor(Math.random() * 20);
      patternState.spacing = parseInt(spacingSlider.value);
      spacingValue.textContent = patternState.spacing;
      
      // Randomize rotation
      rotationSlider.value = Math.floor(Math.random() * 360);
      patternState.rotation = parseInt(rotationSlider.value);
      rotationValue.textContent = patternState.rotation;
      
      // Randomize pattern type
      const patternTypes = ['grid', 'dots', 'checks', 'stripes', 'zigzag', 'ascii', 
                           'diamonds', 'triangles', 'circles', 'pixel', 'retro'];
      const randomType = patternTypes[Math.floor(Math.random() * patternTypes.length)];
      
      // Set the appropriate tab
      const basicTab = document.getElementById('basicTab');
      const complexTab = document.getElementById('complexTab');
      const basicTabContent = document.getElementById('basicTabContent');
      const complexTabContent = document.getElementById('complexTabContent');
      
      // Determine which tab should be active
      const basicPatternTypes = ['grid', 'dots', 'checks', 'stripes', 'zigzag', 'ascii'];
      const isBasicPattern = basicPatternTypes.includes(randomType);
      
      if (isBasicPattern) {
        basicTab.classList.add('active');
        complexTab.classList.remove('active');
        basicTabContent.style.display = 'block';
        complexTabContent.style.display = 'none';
      } else {
        complexTab.classList.add('active');
        basicTab.classList.remove('active');
        complexTabContent.style.display = 'block';
        basicTabContent.style.display = 'none';
      }
      
      // Set the pattern type radio button
      patternTypeRadios.forEach(radio => {
        if (radio.value === randomType) {
          radio.checked = true;
          patternState.type = randomType;
        }
      });
      
      // Generate the randomized pattern
      generatePattern();
    }

    function getRandomColor() {
      // Generate a random hex color
      const letters = '0123456789ABCDEF';
      let color = '#';
      
      for (let i = 0; i < 6; i++) {
        color += letters[Math.floor(Math.random() * 16)];
      }
      
      return color;
    }

    function exportPattern() {
      const exportWidth = parseInt(exportWidthInput.value);
      const exportHeight = parseInt(exportHeightInput.value);
      const format = exportFormatSelect.value;
      const tileBackground = tileBgCheckbox.checked;
      const includeCustom = includeCustomCheckbox.checked;
      
      // Create a temporary canvas for export
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = exportWidth;
      tempCanvas.height = exportHeight;
      const tempCtx = tempCanvas.getContext('2d');
      
      if (tileBackground) {
        // Create a pattern from just the base pattern (no custom elements)
        // We need to create a separate canvas for this
        const patternCanvas = document.createElement('canvas');
        patternCanvas.width = preview.width;
        patternCanvas.height = preview.height;
        const patternCtx = patternCanvas.getContext('2d');
        
        // Draw just the pattern to this canvas
        patternCtx.fillStyle = patternState.bgColor;
        patternCtx.fillRect(0, 0, patternCanvas.width, patternCanvas.height);
        
        // Draw the correct pattern
        switch (patternState.type) {
          case 'grid':
            drawGrid(false, patternCtx);
            break;
          case 'dots':
            drawDots(false, patternCtx);
            break;
          case 'checks':
            drawChecks(false, patternCtx);
            break;
          case 'stripes':
            drawStripes(false, patternCtx);
            break;
          case 'zigzag':
            drawZigzag(false, patternCtx);
            break;
          case 'ascii':
            drawAscii(false, patternCtx);
            break;
          case 'diamonds':
            drawDiamonds(false, patternCtx);
            break;
          case 'triangles':
            drawTriangles(false, patternCtx);
            break;
          case 'circles':
            drawCircles(false, patternCtx);
            break;
          case 'pixel':
            drawPixelArt(false, patternCtx);
            break;
          case 'retro':
            drawRetroCPU(false, patternCtx);
            break;
        }
        
        // Create pattern and fill export canvas
        const pattern = tempCtx.createPattern(patternCanvas, 'repeat');
        tempCtx.fillStyle = pattern;
        tempCtx.fillRect(0, 0, exportWidth, exportHeight);
        
        // If including custom elements, we need to scale and repeat them
        if (includeCustom) {
          // How many tiles fit in the export size
          const tilesX = Math.ceil(exportWidth / preview.width);
          const tilesY = Math.ceil(exportHeight / preview.height);
          
          // Draw custom image if applicable
          if (customImage !== null) {
            tempCtx.globalAlpha = imageOpacity;
            
            if (imageMode === 'background') {
              // Fill with the image as a background
              const pattern = tempCtx.createPattern(customImage, 'repeat');
              tempCtx.fillStyle = pattern;
              tempCtx.fillRect(0, 0, exportWidth, exportHeight);
            } else if (imageMode === 'overlay') {
              // Place the image in each tile
              for (let y = 0; y < tilesY; y++) {
                for (let x = 0; x < tilesX; x++) {
                  const drawX = x * preview.width;
                  const drawY = y * preview.height;
                  tempCtx.drawImage(customImage, drawX, drawY, preview.width, preview.height);
                }
              }
            } else if (imageMode === 'tile') {
              // Already handled by the pattern above
              const pattern = tempCtx.createPattern(customImage, 'repeat');
              tempCtx.fillStyle = pattern;
              tempCtx.fillRect(0, 0, exportWidth, exportHeight);
            }
            
            tempCtx.globalAlpha = 1;
          }
          
          // Draw custom elements in each tile
          for (let y = 0; y < tilesY; y++) {
            for (let x = 0; x < tilesX; x++) {
              for (let element of customElements) {
                if (element.type === 'text') {
                  // Draw text
                  tempCtx.font = `${element.size}px ${element.font}`;
                  tempCtx.fillStyle = element.color;
                  tempCtx.textBaseline = 'top';
                  tempCtx.fillText(element.text, element.x + x * preview.width, element.y + y * preview.height);
                } else if (element.type === 'drawing') {
                  // Draw path
                  tempCtx.strokeStyle = element.color;
                  tempCtx.lineWidth = element.brushSize;
                  tempCtx.lineCap = 'round';
                  tempCtx.lineJoin = 'round';
                  
                  tempCtx.beginPath();
                  for (let i = 0; i < element.points.length; i++) {
                    const point = element.points[i];
                    const drawX = point.x + x * preview.width;
                    const drawY = point.y + y * preview.height;
                    
                    if (i === 0) {
                      tempCtx.moveTo(drawX, drawY);
                    } else {
                      tempCtx.lineTo(drawX, drawY);
                    }
                  }
                  tempCtx.stroke();
                }
              }
            }
          }
        }
      } else {
        // Just scale the single tile with all elements
        tempCtx.drawImage(preview, 0, 0, exportWidth, exportHeight);
      }
      
      // Create data URL based on format
      let mimeType = 'image/png';
      let quality = 1.0;
      
      switch (format) {
        case 'jpg':
          mimeType = 'image/jpeg';
          quality = 0.92;
          break;
        case 'gif':
          mimeType = 'image/gif';
          break;
        case 'png':
        default:
          mimeType = 'image/png';
          break;
      }
      
      try {
        // Get data URL
        const dataURL = tempCanvas.toDataURL(mimeType, quality);
        
        // Set up download
        downloadLink.href = dataURL;
        downloadLink.download = `tiled-bg.${format}`;
        
        // Trigger download
        downloadLink.click();
        
        // Update status
        statusMessage.textContent = `Exported as tiled-bg.${format}`;
      } catch (error) {
        alert('Export failed: ' + error.message);
        statusMessage.textContent = 'Export failed';
      }
    }

    // Initialize on load
    window.addEventListener('load', init);
  </script>
</body>
</html>